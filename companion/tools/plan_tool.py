import re
from typing import List, Dict
from companion.state.agent_state import AgentState, Plan

class PlanTool:
    """
    Manages the high-level plan (Steps).
    Simplified for Sym-Ops v2 - plans are generated by LLM in Markdown format.
    """
    def __init__(self, state: AgentState):
        self.state = state

    async def propose_plan(self, goal: str) -> str:
        """
        Create a plan from LLM-generated Markdown.
        The goal parameter contains the full plan in Markdown format.
        """
        import logging
        logger = logging.getLogger(__name__)
        
        logger.info(f"propose_plan called with goal length: {len(goal)}")
        
        # Create Plan object
        new_plan = Plan(goal=goal)
        
        # Parse steps from Markdown
        steps = self._parse_markdown_steps(goal)
        logger.info(f"Parsed {len(steps)} steps from Markdown")
        
        # Add steps to plan
        for step_data in steps:
            new_plan.add_step(
                title=step_data['title'],
                description=step_data.get('description', '')
            )
        
        # Update State
        self.state.current_plan = new_plan

        result = (
            f"âœ… Plan created with {len(new_plan.steps)} steps.\n"
            f"è¨ˆç”»ãŒä¿å­˜ã•ã‚Œã¾ã—ãŸã€‚çŠ¶æ³ã«å¿œã˜ã¦é©åˆ‡ãªã‚¢ã‚¯ã‚·ãƒ§ãƒ³ã‚’é¸æŠã—ã¦ãã ã•ã„ï¼š\n"
            f"  é€²æ—ã‚’å…±æœ‰ã—ã¤ã¤å®Ÿè¡Œã‚’ç¶šã‘ã‚‹ãªã‚‰ ::note\n"
            f"  ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¨ã®å¯¾è©±ãŒå¿…è¦ï¼ˆä¸æ˜ç‚¹ãƒ»ç¢ºèªãƒ»å…±æœ‰ãªã©ï¼‰ãªã‚‰ ::response"
        )
        logger.info(f"propose_plan completed: {result}")
        return result
    
    def _parse_markdown_steps(self, markdown: str) -> List[Dict[str, str]]:
        """
        Parse steps from Markdown format.
        Expected format:
        ## Step 1: Title
        Description
        
        ## Step 2: Title
        Description
        """
        steps = []
        lines = markdown.split('\n')
        current_step = None
        
        for line in lines:
            # Match: ## Step N: Title (Allow variations in spacing and punctuation)
            match = re.match(r'^##\s*Step\s*\d+[:\s-]*(.+)$', line.strip(), re.IGNORECASE)
            if match:
                # Save previous step
                if current_step:
                    steps.append(current_step)
                
                # Start new step
                current_step = {
                    'title': match.group(1).strip(),
                    'description': []
                }
            elif current_step and line.strip():
                # skip other headers if they accidentally appear mid-step, but collect text
                if not line.strip().startswith('#'):
                    current_step['description'].append(line.strip())
        
        # Save last step
        if current_step:
            steps.append(current_step)
        
        # Join description lines
        for step in steps:
            step['description'] = ' '.join(step['description'])
        
        # Fallback: If no steps found, create single step from entire text
        if len(steps) == 0:
            steps = [{
                'title': 'Implementation Plan',
                'description': markdown[:200] + '...' if len(markdown) > 200 else markdown
            }]
        
        return steps

    async def mark_step_complete(self) -> str:
        """Mark the current step as complete and advance to the next."""
        if not self.state.current_plan:
            return "No active plan."
        
        current_step = self.state.current_plan.get_current_step()
        if current_step:
            from companion.state.agent_state import TaskStatus
            current_step.status = TaskStatus.COMPLETED
            self.state.current_plan.current_step_index += 1
            
            next_step = self.state.current_plan.get_current_step()
            if next_step:
                return f"Step '{current_step.title}' completed. Next step: '{next_step.title}'"
            else:
                self.state.current_plan.is_complete = True
                return f"Step '{current_step.title}' completed. All steps finished! ğŸ‰"
        
        return "No current step."
