## **設計ドキュメント: CodeCrafter (仮称)**

**バージョン:** 1.1
**最終更新日:** 2025年8月7日
**作成者:** Gemini & User

### 1. 概要 (Overview)

#### 1.1. 目的
本プロジェクトの目的は、ローカル開発環境で動作し、ユーザーとの対話を通じてコードの生成、編集、リファクタリング、プロジェクト全体の管理を自律的に支援する、実用的で信頼性の高いAIコーディングエージェント「CodeCrafter」を開発することである。

#### 1.2. 背景
既存のコーディングエージェントツールは、Tool Use（ツールの利用）の精度や文脈理解能力に課題があり、実用的なレベルに達していないケースが多い。本プロジェクトでは、特に「効率的な文脈管理」「柔軟な思考・行動フロー」「安全性」に重点を置くことで、これらの課題を克服し、日常的な開発業務で真に役立つパートナーとなるツールを目指す。

#### 1.3. ゴール
*   **ステップ1:** AIとの対話を通じて、単一ファイルを正確に編集できる。
*   **ステップ2:** 複数のツールを駆使し、プロジェクト全体の文脈を限定的に理解しながら、複数ファイルにまたがる開発タスクを支援できる。
*   **ステップ3:** 高度なコード解析能力と堅牢な安全性を備え、日常業務で信頼して利用できるレベルに到達する。

---

### 2. アーキテクチャ (Architecture)

本エージェントは、関心の分離の原則に基づき、以下の7つの主要コンポーネントで構成される。

1.  **UI (プレゼンテーション層):** ユーザーとのインターフェース。
2.  **ベース (インフラストラクチャ層):** アプリケーションの土台となる機能。
3.  **ツール (実行層):** エージェントが世界に働きかけるための手足。
4.  **プロンプト (思考・推論層):** エージェントの知性と行動規範。
5.  **状態管理 (メモリ層):** エージェントの短期・長期記憶。
6.  **オーケストレーション (制御層):** 全コンポーネントを連携させる心臓部。
7.  **セキュリティ & 評価 (品質保証層):** 安全性と信頼性を担保する仕組み。

**設計思想:** エージェントの**状態(State)**はローカルにリッチなまま保持し、LLMに渡す**プロンプト(Prompt)**は、その状態から毎回、動的に、必要最小限の形で**コンパイル**する。これにより、効率性、性能、機能性を鼎立させる。

---

### 3. 技術仕様 (Technical Specifications)

#### 3.1. 開発・実行環境
*   **実装言語:** **Python 3.10+**
*   **開発環境:** **Windows (WSL2)** を推奨。Linuxの優れた開発エコシステムを活用する。
*   **ターゲット実行環境:** **クロスプラットフォーム (Windows, Linux, macOS)**。
*   **クロスプラットフォーム戦略:**
    *   ファイルパスの操作には **`pathlib`** を全面的に採用する。
    *   OS依存のシェルコマンドは避け、可能な限りPythonライブラリで代替する。
    *   CI/CD（GitHub Actions）にて全プラットフォームでの自動テストを実施する。

#### 3.2. 主要ライブラリとフレームワーク
*   **LLM連携/基盤:** **LangChain**
    *   役割: LLMクライアントの抽象化、ツール呼び出しの抽象化、プロンプトテンプレート、RAGコンポーネントの提供。プロジェクトのほぼ全ての土台として活用する。
*   **オーケストレーション:** **LangGraph**
    *   役割: エージェントのメインループ（思考・行動サイクル）を、柔軟で拡張性の高いグラフベースで制御する。ステップ2から導入。
*   **ターミナルUI:** **Textual** (および **Rich**)
    *   役割: リッチでインタラクティブなTUI（テキストユーザーインターフェース）を構築する。ステップ2から本格導入。
*   **状態管理:** **Pydantic**
    *   役割: エージェントの状態を管理する `AgentState` データクラスを、型安全に定義する。
*   **設定管理:** **PyYAML**, **python-dotenv**
    *   役割: `config.yaml` と `.env` ファイルで、アプリケーションの設定やAPIキーを外部管理する。

#### 3.3. コンポーネント別設計
*   **UI:** ターミナルベース。`rich`によるリッチな出力から始め、`Textual`で多分割レイアウトを持つ本格的なTUIへと進化させる。
*   **ベース:** マルチLLMプロバイダ対応。`config.yaml`の切り替えにより **OpenAI, Anthropic, Google, Groq, OpenRouter** を利用可能にする。包括的なロギング（内部ログ/対話ログ）を実装。
*   **ツール:**
    *   基本: `list_files`, `read_file`, `write_file`, `create_directory`
    *   実行: `execute_shell_command` (コマンドはホワイトリスト化)
    *   解析: RAG (`LangChain`, `ChromaDB`/`FAISS`), LSP (`python-lsp-client`), Tree-sitter
    *   **【AI開発支援用】テスト実行ツール:** `run_tests()`: `pytest`を実行し、結果を構造化して返す。成功、失敗、エラー箇所などを解析しやすい形式にする。
*   **プロンプト:**
    *   **Aider**等のOSSを参考に、役割、行動規範、ReAct思考プロセス、自己修正能力を促す詳細なシステムプロンプトを設計。
    *   プロンプトコンパイラを実装し、`AgentState`から動的にコンテキストを生成する。
*   **状態管理:**
    *   Pydanticで`AgentState`モデルを定義。対話履歴、ワークスペースの状態、タスクの計画などを一元管理する。
*   **オーケストレーション:**
    *   LangGraphを使い、思考、ツール実行、人間による承認、エラーハンドリング（自己修正ループ）といったノードを持つグラフを定義する。
*   **セキュリティ & 評価:**
    *   **セキュリティ:** **人間による承認（Human-in-the-Loop）**を、破壊的・書き込み系のツール実行における必須要件とする。
    *   **評価:** 基本的なコーディングタスクからなる評価データセットを構築し、自動評価パイプラインを整備する。デバッグと評価には**LangSmith**の活用を検討する。

#### **3.4. 【追加項目】AIによる自己開発のための設計原則**
本プロジェクトは、開発するエージェント自身を開発プロセスに活用することを推奨する。これを成功させるため、以下の原則を設計に組み込む。

*   **1. モジュール性と明確な責務:**
    *   各機能（UI, ツール, 状態管理など）を明確にファイルやディレクトリで分離する。これにより、AIに「`agent/tools.py`に新しいツールを追加して」といった具体的な指示を出しやすくなる。
*   **2. Docstringsと型ヒントの徹底:**
    *   全ての関数とクラスに、その目的、引数、戻り値を説明する詳細なDocstringと、正確な型ヒントを記述する。これは、AIがコードの機能を理解するための最も重要な情報源となる。
*   **3. 包括的なテストカバレッジ:**
    *   主要な機能には、ユニットテストと結合テストを記述する。これにより、AIがコードを変更した際に、既存の機能を破壊していないか（リグレッション）を`run_tests`ツールで即座に確認できる。「テスト駆動開発（TDD）」の思想は、AIとのペアプログラミングにおいて極めて有効である。
*   **4. 設定の外部化:**
    *   プロンプト、モデル設定、定数などをコードから分離し、`config.yaml`のような設定ファイルで管理する。これにより、AIはコードロジックに触れることなく、実験的な設定変更を行いやすくなる。

---

### 4. 開発ロードマップ (Development Roadmap)

#### ステップ1: 最小限実装 (Minimum Viable Product - for Personal Use)
*   **目標:** AIとの対話を通じて、単一ファイルを編集できる。
*   **主要技術:** `while`ループによるオーケストレーション、`rich`でのUI、基本的なファイル読み書きツール。
*   **完了条件:** 特定のファイルを読み込ませ、指示に従って内容を書き換えさせることができる。

#### ステップ2: MVP (Minimum Viable Product - for Project Development)
*   **目標:** プロジェクト全体の文脈を限定的に理解し、複数ファイルにまたがる開発タスクを支援できる。
*   **主要技術:** **`LangGraph`** への移行、**`Textual`** の導入、RAGおよびシェル実行ツールの追加、**`Pydantic`** での状態管理。
*   **完了条件:** RAGによるプロジェクト横断検索、複数ツール連携（ライブラリインストールとコード生成など）が可能になる。

#### ステップ3: 実用的なエージェントツール (Polished & Reliable Tool)
*   **目標:** 高度なコード解析能力と堅牢な安全性を備え、日常業務で信頼して使える。
*   **主要技術:** **LSP/Tree-sitter**ツールの導入、プロンプトの高度化、**LangSmith**による評価の本格化。
*   **完了条件:** 曖昧なリファクタリング指示への対応、テストコードの自動修正、CI/CDによる品質保証が実現する。

---
このドキュメントは、プロジェクトの進捗に応じて更新されるリビングドキュメントとする。