## **設計ドキュメント: Duckflow (仮称)**

**バージョン:** 1.1
**最終更新日:** 2025年8月7日
**作成者:** Gemini & User

### 1. 概要 (Overview)

#### 1.1. 目的
本プロジェクトの目的は、ローカル開発環境で動作し、ユーザーとの対話を通じてコードの生成、編集、リファクタリング、プロジェクト全体の管理を自律的に支援する、実用的で信頼性の高いAIコーディングエージェント「CodeCrafter」を開発することである。

#### 1.2. 背景
既存のコーディングエージェントツールは、Tool Use（ツールの利用）の精度や文脈理解能力に課題があり、実用的なレベルに達していないケースが多い。本プロジェクトでは、特に「効率的な文脈管理」「柔軟な思考・行動フロー」「安全性」に重点を置くことで、これらの課題を克服し、日常的な開発業務で真に役立つパートナーとなるツールを目指す。

#### 1.3. ゴール
*   **ステップ1:** AIとの対話を通じて、単一ファイルを正確に編集できる。
*   **ステップ2:** 複数のツールを駆使し、プロジェクト全体の文脈を限定的に理解しながら、複数ファイルにまたがる開発タスクを支援できる。
*   **ステップ3:** 高度なコード解析能力と堅牢な安全性を備え、日常業務で信頼して利用できるレベルに到達する。

---

### 2. アーキテクチャ (Architecture)

本エージェントは、関心の分離の原則に基づき、以下の7つの主要コンポーネントで構成される。

1.  **UI (プレゼンテーション層):** ユーザーとのインターフェース。
2.  **ベース (インフラストラクチャ層):** アプリケーションの土台となる機能。
3.  **ツール (実行層):** エージェントが世界に働きかけるための手足。
4.  **プロンプト (思考・推論層):** エージェントの知性と行動規範。
5.  **状態管理 (メモリ層):** エージェントの短期・長期記憶。
6.  **オーケストレーション (制御層):** 全コンポーネントを連携させる心臓部。
7.  **セキュリティ & 評価 (品質保証層):** 安全性と信頼性を担保する仕組み。

**設計思想:** エージェントの**状態(State)**はローカルにリッチなまま保持し、LLMに渡す**プロンプト(Prompt)**は、その状態から毎回、動的に、必要最小限の形で**コンパイル**する。これにより、効率性、性能、機能性を鼎立させる。

---

### 3. 技術仕様 (Technical Specifications)

#### 3.1. 開発・実行環境
*   **実装言語:** **Python 3.10+**
*   **開発環境:** **Windows (WSL2)** を推奨。Linuxの優れた開発エコシステムを活用する。
*   **ターゲット実行環境:** **クロスプラットフォーム (Windows, Linux, macOS)**。
*   **クロスプラットフォーム戦略:**
    *   ファイルパスの操作には **`pathlib`** を全面的に採用する。
    *   OS依存のシェルコマンドは避け、可能な限りPythonライブラリで代替する。
    *   CI/CD（GitHub Actions）にて全プラットフォームでの自動テストを実施する。

#### 3.2. 主要ライブラリとフレームワーク
*   **LLM連携/基盤:** **LangChain**
    *   役割: LLMクライアントの抽象化、ツール呼び出しの抽象化、プロンプトテンプレート、RAGコンポーネントの提供。プロジェクトのほぼ全ての土台として活用する。
*   **オーケストレーション:** **LangGraph**
    *   役割: エージェントのメインループ（思考・行動サイクル）を、柔軟で拡張性の高いグラフベースで制御する。ステップ2から導入。
*   **ターミナルUI:** **Textual** (および **Rich**)
    *   役割: リッチでインタラクティブなTUI（テキストユーザーインターフェース）を構築する。ステップ2から本格導入。
*   **状態管理:** **Pydantic**
    *   役割: エージェントの状態を管理する `AgentState` データクラスを、型安全に定義する。
*   **設定管理:** **PyYAML**, **python-dotenv**
    *   役割: `config.yaml` と `.env` ファイルで、アプリケーションの設定やAPIキーを外部管理する。

#### 3.3. コンポーネント別設計
*   **UI:** ターミナルベース。`rich`によるリッチな出力から始め、`Textual`で多分割レイアウトを持つ本格的なTUIへと進化させる。
*   **ベース:** マルチLLMプロバイダ対応。`config.yaml`の切り替えにより **OpenAI, Anthropic, Google, Groq, OpenRouter** を利用可能にする。包括的なロギング（内部ログ/対話ログ）を実装。
*   **ツール:**
    *   基本: `list_files`, `read_file`, `write_file`, `create_directory`
    *   実行: `execute_shell_command` (コマンドはホワイトリスト化)
    *   解析: RAG (`LangChain`, `ChromaDB`/`FAISS`), LSP (`python-lsp-client`), Tree-sitter
    *   **【AI開発支援用】テスト実行ツール:** `run_tests()`: `pytest`を実行し、結果を構造化して返す。成功、失敗、エラー箇所などを解析しやすい形式にする。
*   **プロンプト:**
    *   **Aider**等のOSSを参考に、役割、行動規範、ReAct思考プロセス、自己修正能力を促す詳細なシステムプロンプトを設計。
    *   プロンプトコンパイラを実装し、`AgentState`から動的にコンテキストを生成する。
*   **状態管理:**
    *   Pydanticで`AgentState`モデルを定義。対話履歴、ワークスペースの状態、タスクの計画などを一元管理する。
*   **オーケストレーション:**
    *   LangGraphを使い、思考、ツール実行、人間による承認、エラーハンドリング（自己修正ループ）といったノードを持つグラフを定義する。
*   **セキュリティ & 評価:**
    *   **セキュリティ:** **人間による承認（Human-in-the-Loop）**を、破壊的・書き込み系のツール実行における必須要件とする。
    *   **評価:** 基本的なコーディングタスクからなる評価データセットを構築し、自動評価パイプラインを整備する。デバッグと評価には**LangSmith**の活用を検討する。

#### **3.4. 【追加項目】AIによる自己開発のための設計原則**
本プロジェクトは、開発するエージェント自身を開発プロセスに活用することを推奨する。これを成功させるため、以下の原則を設計に組み込む。

*   **1. モジュール性と明確な責務:**
    *   各機能（UI, ツール, 状態管理など）を明確にファイルやディレクトリで分離する。これにより、AIに「`agent/tools.py`に新しいツールを追加して」といった具体的な指示を出しやすくなる。
*   **2. Docstringsと型ヒントの徹底:**
    *   全ての関数とクラスに、その目的、引数、戻り値を説明する詳細なDocstringと、正確な型ヒントを記述する。これは、AIがコードの機能を理解するための最も重要な情報源となる。
*   **3. 包括的なテストカバレッジ:**
    *   主要な機能には、ユニットテストと結合テストを記述する。これにより、AIがコードを変更した際に、既存の機能を破壊していないか（リグレッション）を`run_tests`ツールで即座に確認できる。「テスト駆動開発（TDD）」の思想は、AIとのペアプログラミングにおいて極めて有効である。
*   **4. 設定の外部化:**
    *   プロンプト、モデル設定、定数などをコードから分離し、`config.yaml`のような設定ファイルで管理する。これにより、AIはコードロジックに触れることなく、実験的な設定変更を行いやすくなる。

---

### 4. 開発ロードマップ (Development Roadmap)

#### ステップ1: 最小限実装 (Minimum Viable Product - for Personal Use)
*   **目標:** AIとの対話を通じて、単一ファイルを編集できる。
*   **主要技術:** `while`ループによるオーケストレーション、`rich`でのUI、基本的なファイル読み書きツール。
*   **完了条件:** 特定のファイルを読み込ませ、指示に従って内容を書き換えさせることができる。

#### ステップ2: MVP (Minimum Viable Product - for Project Development)
*   **目標:** エージェントの「脳」と「骨格」を、将来の拡張に耐えうるモダンなアーキテクチャに刷新する。
*   **目標:** エージェントが、プロジェクト全体のコードを「読んで」「検索」できるようになる（＝長期記憶の基盤実装）。
*   **目標:** プロジェクト全体の文脈を限定的に理解し、複数ファイルにまたがる開発タスクを支援できる。
*   **主要技術:** **`LangGraph`** への移行、**`Textual`** の導入、RAGおよびシェル実行ツールの追加、**`Pydantic`** での状態管理。
*   **完了条件:** RAGによるプロジェクト横断検索、複数ツール連携（ライブラリインストールとコード生成など）が可能になる。

##### ステップ2の細分化ロードマップ案

###### **ステップ2a: 基盤の刷新と拡張 (Foundation Upgrade)**

**目標:** **エージェントの「脳」と「骨格」を、将来の拡張に耐えうるモダンなアーキテクチャに刷新する。**
このステップでは、ユーザーから見える機能はあまり変わりませんが、内部構造が劇的に進化します。

*   **オーケストレーションの移行:**
    *   自作の`while`ループを、**`LangGraph`** に置き換える。
    *   まずは「思考」と「ツール実行」の2つのノードを持つシンプルなグラフを実装する。この段階で、自己修正ループなどの複雑な機能は不要。
*   **状態管理の堅牢化:**
    *   状態を管理しているPythonの辞書を、**`Pydantic`** の`AgentState`モデルに置き換える。これにより、状態の型安全性が保証され、開発効率が向上する。
*   **ツールの拡充（基本編）:**
    *   `list_files(recursive=True)` や `create_directory` といった、基本的なファイルシステム操作ツールを追加する。
    *   `execute_shell_command` ツールを導入する。ただし、この段階では`ls`や`git status`など、ごく一部の安全な読み取り専用コマンドのみをホワイトリストで許可する。
*   **UIの準備:**
    *   **`Textual`** を導入し、画面を「チャット表示エリア」と「入力エリア」に分割した、ごく基本的なレイアウトだけを作成する。まだファイルツリーなどのリッチな機能は不要。

**完了条件:**
*   内部の制御フローが`LangGraph`で動いている。
*   エージェントが、カレントディレクトリを認識し、ファイル一覧を表示したり、新しいディレクトリを作成したりできる。

---

###### **ステップ2b: プロジェクト理解能力の獲得 (Context-Awareness)**

**目標:** **エージェントが、プロジェクト全体のコードを「読んで」「検索」できるようになる。**
ここからエージェントは、単一ファイルの枠を超えた「プロジェクトレベルの文脈」を扱えるようになります。

*   **RAG (検索拡張生成) の導入:**
    *   `LangChain`と`ChromaDB`（または`FAISS`）を使い、プロジェクトのコードをベクトル化して検索する機能を実装する。
    *   **`index_project()`**: プロジェクトをインデックス化する。
    *   **`search_code(query: str)`**: ユーザーの質問で関連コードを検索する。
*   **プロンプトコンパイラの構築:**
    *   `AgentState`と、`search_code`の結果を組み合わせて、LLMに渡すプロンプトを動的に生成する`prompt_compiler.py`を本格的に実装する。
*   **UIの強化:**
    *   `Textual`のUIに、`search_code`の結果や`list_files`の結果を表示するための専用のサイドパネルやビューを追加する。

**完了条件:**
*   ユーザーが「このプロジェクトでデータベースに接続しているコードはどこ？」と質問し、エージェントが関連するファイルと関数をリストアップできる。
*   エージェントが、質問に答えるために、自律的に`search_code`ツールを使用できる。

---

###### **ステップ2c: 長期的な対話の文脈をAIが記憶し、人間との自然なやり取りを維持できるようにする。**
このステップで、エージェントは「一問一答」を卒業し、過去の発言を踏まえた「文脈のある対話」が可能になります。

*   **短期記憶 (ワーキングメモリ) の実装:**
    *   `AgentState`に`history: List[Dict]`フィールドを本格的に活用する。
    *   `LangGraph`の各サイクルの終わりに、ユーザー入力とAIの応答（思考過程を含む）を`history`に追加するロジックを実装する。
*   **中期記憶 (エピソード記憶) の実装:**
    *   `history`のトークン数が一定量を超えた際の**要約戦略**を実装する。
    *   `AgentState`に`history_summary: str`フィールドを追加。
    *   高速・低コストなLLM（例: Haiku, GPT-4o-mini）を使い、古い履歴を要約して`history_summary`に保存し、元の履歴を切り詰める機能を実装する。
*   **プロンプトコンパイラの強化:**
    *   LLMに渡すプロンプトを、`[要約(中期)] + [直近の履歴(短期)] + [RAG結果(長期)]`という階層構造で動的に組み立てるように`prompt_compiler.py`を改良する。

**完了条件:**
*   ユーザーが5〜10ターン以上の対話を続けた後でも、AIが初期の指示（例:「このセッションの目標は〇〇を作ること」）を覚えている。
*   「さっき言った〇〇についてだけど」といった指示を、AIが正しく理解し、応答できる。


---

###### **ステップ2d: 自律的なタスク実行能力 (Task Execution)**

**目標:** **複数のツールを連続して使用し、ユーザーの指示に基づいた具体的な開発タスクを完了できるようになる。**
このステップで、エージェントはついに「コードを読んで質問に答える」だけではなく、「実際に手を動かして開発を進める」能力を獲得します。

*   **LangGraphの高度化:**
    *   **人間による承認 (Human-in-the-Loop)** ノードをグラフに追加する。`write_file`や危険なシェルコマンドを実行する前に、必ずこのノードを経由させる。
    *   ツール実行でエラーが発生した場合に、そのエラー情報を`AgentState`に記録し、再度「思考」ノードに戻す**自己修正（再試行）ループ**を実装する。
*   **ツールの拡充（実行編）:**
    *   `execute_shell_command`ツールのホワイトリストに、`pip install`や`pytest`などのコマンドを追加する。
    *   `run_tests()`ツールを実装し、テスト結果を構造化して`AgentState`にフィードバックできるようにする。
*   **評価の開始:**
    *   プロジェクトの現在の状態（ステップ2c完了時点）で解けるべき、5個程度の**評価データセット**（例: 「requestsをインストールし、example.comにGETリクエストを送るコードを書いて」）を作成し、手動で性能をテストする。

**完了条件:**
*   ユーザーが「`pytest-mock`をインストールして、`tests/test_api.py`に新しいモックテストを追加して」という一連の指示を、エージェントが（途中で人間の承認を挟みながら）最後までやり遂げることができる。
*   エージェントが、自ら書いたコードに対して`run_tests`を実行し、失敗した場合はその修正を試みることができる。

#### ステップ3: 実用的なエージェントツール (Polished & Reliable Tool)
*   **目標:** 高度なコード解析能力と堅牢な安全性を備え、日常業務で信頼して使える。
*   **主要技術:** **LSP/Tree-sitter**ツールの導入、プロンプトの高度化、**LangSmith**による評価の本格化。
*   **長期記憶の高度活用:**
    *   単にRAGで検索するだけでなく、プロジェクトのコーディングスタイルやアーキテクチャパターンを**自動で学習・要約**し、`AgentState`に保持する機能を実装する。
    *   AIが新しいコードを生成する際に、この学習済みスタイルガイドをプロンプトに含めることで、プロジェクト全体の一貫性を自動で保つようにする。
*   **完了条件:** 曖昧なリファクタリング指示への対応、テストコードの自動修正、CI/CDによる品質保証が実現する。

---
このドキュメントは、プロジェクトの進捗に応じて更新されるリビングドキュメントとする。