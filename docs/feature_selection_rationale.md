# 機能の取捨選択とその理由

Duckflow v4 再構築にあたり、過去のバージョン（v1-v3, codecrafter）から「何を残し、何を捨てるか」の判断基準をまとめました。

## ✅ 採用・継承するもの

| 機能/概念 | 出典 | 採用理由 |
| :--- | :--- | :--- |
| **Unified Tool Call** | v4/v7 | **[核心]** 思考（Action生成）と行動（実行）を分離し、システムの予測可能性と安定性を劇的に高めるため。 |
| **階層的プランニング** | v7 | 「スネークゲーム作って」のような抽象的な指示を、実行可能な単位まで確実に分解するため。 |
| **D.U.C.K. Vitals** | v3 | 単なるツールではなく「相棒」として、無限ループ防止や品質管理をゲーム感覚で可視化するため。 |
| **Duck Call** | v3 | AIの独断を防ぎ、ユーザーをループに巻き込む（Human-in-the-loop）ための最適なUXであるため。 |
| **Rich UI** | v1-v3 | ターミナルでの視認性が高く、既に実装資産があるため流用。 |

## 🗑️ 廃止・簡素化するもの

| 機能/概念 | 理由 | 代替案 |
| :--- | :--- | :--- |
| **LangGraph** | **[複雑性排除]** 状態管理がブラックボックス化しやすく、デバッグが困難だったため。 | シンプルな Python `while` ループと条件分岐（Dispatcher）で実装。 |
| **7ノード/5ノード構成** | **[情報ロス防止]** ノード間のメッセージパッシングで文脈が落ちる問題があったため。 | 「司令塔 (Core)」と「作業員 (Worker)」の2層のみに集約。 |
| **PromptSmith** | **[時期尚早]** プロンプトの自己改善は魅力的だが、まずはコア機能の安定化が最優先であるため。 | 将来的な拡張として保留（Part 2以降）。 |
| **複雑な意図分類器** | **[統合]** ルールベースの分類器は保守が大変だったため。 | メインLLMのコンテキスト判断と `Action` 生成に任せる。 |
| **RAGツール群** | **[シンプル化]** 初期段階では過剰装備であり、コンテキスト汚染の原因になるため。 | 必要になった段階で `duck_scan` としてシンプルに再実装。 |

## 結論
**「複雑なフレームワーク（LangGraph）への依存を捨て、データ構造（State/Action）とプロンプトによる制御に回帰する」**
これが v4 の基本戦略です。