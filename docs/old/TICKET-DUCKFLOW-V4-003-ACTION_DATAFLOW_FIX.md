# TICKET-ID: DUCKFLOW-V4-003

**TITLE:** Implement Action-to-Action Dataflow (`ref:` Syntax)

## 1. BACKGROUND

Analysis of conversation logs revealed a critical issue where the AI can generate a valid multi-step `ActionList`, but fails during execution. Specifically, the system cannot pass the result of one action (e.g., a `plan_id` from `plan_tool.propose`) to a subsequent action (e.g., `task_tool.generate_list`).

This is evidenced by the recurring `{"success": False, "error": "ステップが見つかりません"}` error and the corresponding `WARNING - 参照IDが見つかりません` log. This failure in the dataflow pipeline prevents any complex, multi-tool operations from succeeding and is a blocker for the v4 architecture.

## 2. OBJECTIVE

The action dispatcher must be enhanced to correctly resolve `ref:`-based arguments. It must dynamically inject the output of a previous action into the input of a subsequent action within the same `ActionList` execution cycle.

## 3. IMPLEMENTATION PLAN

The implementation AI shall perform the following tasks.

**Primary File to Modify:** `companion/enhanced_core_v8.py`

1.  **Enhance the Dispatch Loop:**
    *   The method responsible for iterating through the `ActionList` (likely `_dispatch_actions` or a similar method) must be made stateful for the duration of the turn.
    *   Before the loop begins, initialize an empty dictionary (e.g., `turn_results: Dict[str, Any] = {}`) to store the results of executed actions that have an `action_id`.

2.  **Implement Argument Pre-processing and Reference Injection:**
    *   Inside the loop, for each `action` about to be executed, create a new function or logic block to pre-process its arguments (`action.args`).
    *   This pre-processor must iterate through the `action.args`. If an argument's value is a string that starts with the prefix `"ref:"`, it must perform a lookup.
    *   The reference ID (the substring after `"ref:"`) should be used as a key to look into the `turn_results` dictionary.
    *   If the key exists, replace the `"ref:some_id"` string with the actual value stored in `turn_results[some_id]`.
    *   If the key does not exist, this is a critical error. The action should not be executed, and an error should be logged and returned for this action.

3.  **Store Action Results:**
    *   After an action is successfully executed, check if it has a non-empty `action_id`.
    *   If it does, store the return value of the action in the `turn_results` dictionary with the `action_id` as the key.

### Conceptual Code Example

The logic within the dispatching method should resemble the following:

```python
# Inside a method like _dispatch_actions(self, action_list: List[ActionV8])

# Dictionary to hold results for the current turn
turn_results: Dict[str, Any] = {}

for action in action_list:
    try:
        # Pre-process arguments to resolve references
        processed_args = self._preprocess_action_args(action.args, turn_results)

        # Execute the action with resolved arguments
        result = await self._execute_action_v8(action.operation, processed_args)

        # If the action has an ID, store its result for future actions
        if action.action_id:
            turn_results[action.action_id] = result

    except Exception as e:
        # Handle errors, e.g., a reference not found in _preprocess_action_args
        self.logger.error(f"Failed to execute action {action.operation}: {e}")
        result = {"success": False, "error": str(e)}
        if action.action_id:
            turn_results[action.action_id] = result
        # Decide whether to break or continue the loop
        break
```

## 4. ACCEPTANCE CRITERIA

1.  The system must successfully resolve `ref:`-based arguments between actions in an `ActionList`.
2.  The specific error `{"success": False, "error": "ステップが見つかりません"}` for `task_tool.generate_list` should no longer occur when it follows a `plan_tool.propose` action.
3.  A plan-generate-run sequence, as generated by the AI in the logs, must execute without dataflow errors.
