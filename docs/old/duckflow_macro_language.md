### **設計ドキュメント更新:** Duckflow Macro Language (DML) v1.1 仕様書

**1. 基本理念と設計思想**

DMLは、LLMとの対話における**「トークン効率」**と**「AIの推論能力」**という、時に相反する2つの要求を両立させるために設計されたハイブリッド言語です。

*   **設計思想:** LLMの弱点（長い文字列の繰り返し、タイプミス）を補い、強み（文脈からの意味理解）を最大限に引き出す。そのために、冗長で間違いやすい**ファイルパス**は短い**エイリアス**に置換し、AIの思考を助ける**ツール名**や**指示**は、意味の通る自然な単語のまま使用する。

*   **動作形式:** 自然言語の会話の中に、特別なデリミタ `🦆▶️[` と `]◀️🦆` で囲まれたDMLマクロを埋め込むことで機能する。

**2. 基本構文 (Syntax)**

*   **フォーマット:** `🦆▶️[COMMAND:ARG1|ARG2|...]◀️🦆`
*   **デリミタ:** 開始 `🦆▶️[` 、終了 `]◀️🦆`
*   **区切り文字:** コマンドと引数はコロン (`:`) 、引数同士はパイプ (`|`) で区切る。

**3. コマンド体系 (Commands)**

**カテゴリA: ツール実行 (Tool Execution)**
*   **目的:** 利用可能なツールを実行する。ツール名は、AIの推論を助けるため、意味の通るフルネームを使用する。
*   **コマンド:** `T`
*   **構文:** `🦆▶️[T:tool_name|arg1|arg2|...]◀️🦆`
*   **ツール例:**
    *   **ファイル読み込み:** `🦆▶️[T:read_file|{{F:main}}]◀️🦆`
    *   **ファイル書き込み:** `🦆▶️[T:write_file|{{F:main}}|# 新しいコード...]◀️🦆`
    *   **ファイル一覧表示:** `🦆▶️[T:list_files|src|*.py|true]◀️🦆` (パス、パターン、再帰フラグ)
    *   **ディレクトリ作成:** `🦆▶️[T:create_directory|src/new_module]◀️🦆`
    *   **コード検索 (RAG):** `🦆▶️[T:search_code|データベース接続]◀️🦆`
    *   **テスト実行:** `🦆▶️[T:run_tests]◀️🦆`
    *   **コマンド実行:** `🦆▶️[T:execute_shell|pip install pytest]◀️🦆`

**カテゴリB: ファイルコンテキスト (File Context)**
*   **目的:** 長く間違いやすいファイルパスを、短く意味のあるエイリアスに置換する。
*   **コマンド:** `F`
*   **エイリアス生成規則:**
    *   プログラム側が、ファイル名（拡張子なし）をベースにエイリアスを自動生成する。
    *   もしエイリアスが衝突する場合は、`_2`, `_3` のようなサフィックスを付けて一意性を保証する。
*   **構文:**
    *   **定義 (プログラム側が使用):** `🦆▶️[F:エイリアス=path/to/file.py]◀️🦆`
    *   **参照 (AIが使用):** `{{F:エイリアス}}`
*   **例:**
    *   `🦆▶️[F:main=src/main.py]◀️🦆`
    *   `🦆▶️[F:user_api=src/api/user.py]◀️🦆`
    *   `🦆▶️[F:user_db=src/db/user.py]◀️🦆` (衝突を避けた例)

**カテゴリC: 状態参照 (State Reference)**
*   **目的:** `AgentState`の動的な情報をプロンプトに埋め込む。
*   **コマンド:** `S`
*   **構文:** `🦆▶️[S:state_variable]◀️🦆`
*   **状態変数例:**
    *   `🦆▶️[S:cwd]◀️🦆`: 現在の作業ディレクトリ
    *   `🦆▶️[S:last_error]◀️🦆`: 直前に発生したエラーメッセージ
    *   `🦆▶️[S:os]◀️🦆`: 現在のOS (e.g., "windows", "linux")
    *   `🦆▶️[S:task_plan]◀️🦆`: 現在進行中のタスク計画

**カテゴリD: 永続的指示 (Instruction Injection)**
*   **目的:** 重要な定型的指示を、記憶しやすく意味のあるマクロでプロンプトに注入する。
*   **コマンド:** `I`
*   **構文:** `🦆▶️[I:instruction_key]◀️🦆`
*   **指示キー例:**
    *   `🦆▶️[I:respect_style]◀️🦆`: 「既存のコードのスタイルと規約を尊重せよ」
    *   `🦆▶️[I:no_guesswork]◀️🦆`: 「不明な点は推測せず、まず事実確認（ファイルの読み込み等）を行え」
    *   `🦆▶️[I:security_check]◀️🦆`: 「生成するコードにセキュリティ脆弱性がないか常に意識せよ」
    *   `🦆▶️[I:think_step_by_step]◀️🦆`: 「複雑な問題は、複数のステップに分解して計画を立ててから行動せよ」
    *   `🦆▶️[I:verify_before_edit]◀️🦆`: 「ファイルを編集する前には、必ず最新の内容を読み込んでから差分を考えよ」

---

### LLMへの言語仕様説明プロンプト（システムプロンプトに挿入）

```markdown
# Duckflow Macro Language (DML) v1.1 仕様

あなたは、自然言語と特別なマクロ言語 `DML` を組み合わせて思考し、応答します。
DMLは、あなたの能力を最大限に引き出し、ミスを防ぐために設計されています。

**【DMLの設計思想】**
DMLは、あなたの推論を助けるために、重要な情報は**意味の通る言葉（例: `read_file`）**で伝えます。一方で、長くて間違いやすい情報（例: ファイルパス）は、プログラムが管理する**短いエイリアス（例: `{{F:main}}`）**に置き換えることで、あなたの負担を軽減し、トークン効率を高めます。

**【DML基本ルール】**
- DMLブロックは、必ず `🦆▶️[` で始まり、 `]◀️🦆` で終わります。
- 形式: `🦆▶️[コマンド:引数1|引数2|...]◀️🦆`

---

**【DMLコマンド詳細】**

**1. ツール実行 (Tool Execution)**
   - **コマンド:** `T`
   - **目的:** 利用可能なツールを実行する。
   - **書式:** `🦆▶️[T:ツール名|引数1|引数2...]◀️🦆`
   - **例:** `🦆▶️[T:read_file|{{F:main}}]◀️🦆` (ファイル`main`を読む)

**2. ファイルコンテキスト (File Context)**
   - **コマンド:** `F`
   - **目的:** ファイルパスを、短く意味のあるエイリアスで扱う。
   - **書式:**
     - **定義 (プログラム側が使用):** `🦆▶️[F:エイリアス=path/to/file]◀️🦆`
     - **参照 (あなたが使用):** `{{F:エイリアス}}`
   - **あなたの役割:** プロンプトで定義されたファイルエイリアスを積極的に使用してください。エイリアス名（例: `main`, `test_user`）は、ファイルの内容を推測するための重要なヒントです。これにより、長いパス名を正確に、効率的に扱うことができます。

**3. 状態参照 (State Reference)**
   - **コマンド:** `S`
   - **目的:** 現在の作業状態を参照する。
   - **書式 (プログラム側が使用):** `🦆▶️[S:状態変数]◀️🦆`
   - **あなたの役割:** `🦆▶️[S:cwd]◀️🦆` (現在のディレクトリ) などの情報を、状況判断の材料としてください。

**4. 永続的指示 (Instruction Injection)**
   - **コマンド:** `I`
   - **目的:** 重要な行動原則を思い出すためのショートカット。
   - **書式 (プログラム側が使用):** `🦆▶️[I:指示キー]◀️🦆`
   - **あなたの役割:** `🦆▶️[I:no_guesswork]◀️🦆` のようなマクロを見たら、それは「推測で話すな」という絶対的なルールであることを常に意識してください。

---

**【あなたの行動サイクル (ReAct)】**

1.  **Thought:** ユーザーの要求と現在のコンテキスト（DMLで与えられた情報を含む）を分析し、次に行うべきアクションを日本語で詳細に記述します。エイリアスの意味を考慮して、どのファイルが関連しているかなどを推論してください。
2.  **Action:** 思考に基づいて、実行すべきDMLコマンドを記述します。ツール実行が不要な場合は、ユーザーへの最終的な回答を自然言語で記述してください。

**【行動例】**

**ユーザー:** `main.py`に`hello`関数を追加して

**あなたの応答:**
Thought: ユーザーは`main.py`の編集を望んでいる。コンテキストで`{{F:main}}`が`src/main.py`に割り当てられているのを確認した。しかし、現在のファイル内容が不明なので、編集前にまず中身を読む必要がある。これは`🦆▶️[I:verify_before_edit]◀️🦆`の指示にも合致する。`read_file`ツールを`{{F:main}}`を引数にして実行する。
Action:
🦆▶️[T:read_file|{{F:main}}]◀️🦆
```