
# プロジェクトDuckflow 設計ドキュメント

**バージョン:** 1.2
**ステータス:** ステップ1（最小限実装）がほぼ完了。ステップ2への移行準備段階。

## 1. プロジェクトのビジョンと目的

Duckflowは、開発者のローカル環境で動作する、対話型のAIコーディングエージェントです。その主な目的は、ソフトウェア開発者にとっての知的なパートナーとして、コードの生成、リファクタリング、プロジェクト管理を直接支援することです。

**このプロジェクトが解決したいこと:**
既存のツールが持つ「Tool Use（ツールの利用）の精度の低さ」や「文脈理解の甘さ」といった課題を、以下の3つの柱に重点を置くことで克服します。
1.  **効率的な文脈管理:** LLMを呼び出すたびに、関連性の高い情報を最小限の形で賢く組み立てる。
2.  **柔軟な実行制御:** グラフベースの制御フローを用いて、複雑なタスクやエラーからの自己修正を可能にする。
3.  **開発者中心の体験:** ターミナル上で、キーボード中心のシームレスな操作感を提供する。

## 2. 開発の基本方針（AIへの指示）

このプロジェクトは、開発するエージェント（Duckflow）自身を開発プロセスに活用することを推奨します。AIとしてこのプロジェクトの開発に貢献する際は、以下の原則に**必ず**従ってください。

1.  **役割分担が明確なモジュール構成:**
    *   機能ごと（例: ツール群、UI、状態管理）に、ファイルを明確に分けてください。
    *   新しい機能を追加する際は、既存の適切なファイルに追加するか、新しいファイルを作成してください。複数の役割を一つのファイルに混ぜないでください。
    *   あなたへの指示は、「`codecrafter/tools/file_tools.py`に新しいツールを追加してください」のような具体的な形で行われます。

2.  **丁寧な説明書（Docstring）と型ヒント:**
    *   **すべての**関数、メソッド、クラスには、その目的、引数(`Args:`)、戻り値(`Returns:`)を説明する、分かりやすいDocstringを**必ず**記述してください。
    *   **すべての**引数と戻り値には、正確な型ヒントを**必ず**付けてください。
    *   これは交渉の余地がありません。あなた自身がコードベースを理解するための最も重要な情報源です。

3.  **テストを重視する文化:**
    *   新しいツールや重要な機能を追加した際には、`tests/`ディレクトリに対応するテストを記述してください。
    *   コードを変更するタスクを完了する前には、`run_tests`ツールを実行し、既存の機能を壊していないか（リグレッション）を確認してください。
    *   テストカバレッジを維持、向上させることが目標です。

4.  **設定はコードの外に:**
    *   プロンプトのテンプレートやモデル名といった設定値を、コード内に直接書き込まないでください。
    *   これらは`config.yaml`のような設定ファイルで管理し、コードからはその設定を読み込むようにしてください。

## 3. アーキテクチャと技術スタック

### ステップ1（現在）: 最小限実装
シンプルな`while`ループベースの構成で基本機能を実装。

*   **UI:** `Rich` を利用したターミナルUI
*   **ベース:** 直接LLM APIクライアントの抽象化
*   **ツール:** Python関数によるファイル操作ツール群
*   **プロンプト:** 文字列テンプレートによるシステムプロンプト
*   **状態管理:** `Pydantic`モデルで定義されたエージェントの記憶
*   **オーケストレーション:** シンプルなメインループ
*   **品質保証:** 人間による承認機能

### ステップ2（計画）: MVP実装
システムは7つの部品から構成され、これらは`LangGraph`によって制御（オーケストレーション）される予定。

*   **UI:** `Textual` を利用したターミナルUI
*   **ベース:** `LangChain` を利用したLLMクライアントの抽象化
*   **ツール:** `@tool`デコレータを付けたPython関数の集まり
*   **プロンプト:** 状態（State）から動的に組み立てられるプロンプト
*   **状態管理:** `Pydantic`モデルで定義されたエージェントの記憶
*   **オーケストレーション:** `LangGraph` によるメインの実行ループ
*   **品質保証:** 人間による承認と、自動化されたテスト

### 技術スタック（現在）
*   **言語:** Python 3.10以降 UVの使用
*   **UI:** Rich（現在）, Textual（計画）
*   **LLMプロバイダー:** OpenAI, Anthropic, Google, Groq, OpenRouter対応
*   **状態・設定管理:** Pydantic, PyYAML, python-dotenv

## 4. ディレクトリ構成（現在）

```
.
├── codecrafter/             # メインパッケージ
│   ├── __init__.py
│   ├── main.py              # ✅ メインアプリケーション
│   ├── base/
│   │   ├── __init__.py
│   │   ├── config.py        # ✅ 設定管理
│   │   └── llm_client.py    # ✅ LLMクライアント抽象化
│   ├── state/
│   │   ├── __init__.py
│   │   └── agent_state.py   # ✅ AgentStateのPydanticモデル
│   ├── tools/
│   │   ├── __init__.py
│   │   └── file_tools.py    # ✅ ファイル操作ツール群
│   ├── ui/
│   │   ├── __init__.py
│   │   └── rich_ui.py       # ✅ Richベースの UI
│   ├── prompts/             # ✅ 構造のみ（未実装）
│   │   └── __init__.py
│   └── security/            # ✅ 構造のみ（未実装）
│       └── __init__.py
├── tests/                   # ❌ 未実装
│   └── __init__.py
├── config/
│   └── config.yaml          # ✅ 設定ファイル
├── main.py                  # ✅ エントリーポイント
├── pyproject.toml          # ✅ プロジェクト設定
├── requirements.txt        # ✅ 依存関係
├── PROGRESS.md             # ✅ 進捗記録
└── CLAUDE.md              # ✅ このドキュメント
```

## 5. AgentStateオブジェクト：エージェントの記憶（実装済み）

これは、エージェントの「記憶」を表現する中心的なデータです。現在はシンプルなループで使用され、将来的にLangGraphの各処理（ノード）で使用される予定です。

```python
from pydantic import BaseModel, Field
from typing import List, Dict, Optional, Any
from datetime import datetime

class ConversationMessage(BaseModel):
    """対話メッセージを表現するクラス"""
    role: str = Field(description="メッセージの役割 (user, assistant, system)")
    content: str = Field(description="メッセージの内容")
    timestamp: datetime = Field(default_factory=datetime.now)
    metadata: Dict[str, Any] = Field(default_factory=dict)

class AgentState(BaseModel):
    """エージェントの全体状態を管理するメインクラス"""
    # 対話履歴
    conversation_history: List[ConversationMessage] = Field(default_factory=list)
    
    # 現在のタスク
    current_task: Optional[str] = Field(default=None)
    task_steps: List[TaskStep] = Field(default_factory=list)
    
    # エージェントのメタデータ
    session_id: str = Field(description="セッションID")
    created_at: datetime = Field(default_factory=datetime.now)
    last_activity: datetime = Field(default_factory=datetime.now)
    
    # 設定とフラグ
    debug_mode: bool = Field(default=False)
    auto_approve: bool = Field(default=False)
```

## 6. 主要なツール群

### 実装済み（ステップ1）
*   **`list_files(path: str = ".") -> List[Dict]`**: 指定された場所のファイルやディレクトリを一覧表示する。
*   **`read_file(path: str) -> str`**: 指定されたファイルの内容を読み込む。
*   **`write_file(path: str, content: str) -> Dict`**: 指定されたファイルに内容を書き込む。**人間の承認が必須**。バックアップ機能付き。
*   **`get_file_info(path: str) -> Dict`**: ファイル/ディレクトリの詳細情報を取得する。
*   **`create_directory(path: str) -> Dict`**: ディレクトリを作成する。**人間の承認が必須**。

### AI対話システム（実装済み）
*   **対話履歴管理**: メッセージの追加・取得
*   **ファイル操作指示解析**: `FILE_OPERATION:CREATE/EDIT` フォーマット対応
*   **セキュリティ承認**: ファイル書き込み前の確認とプレビュー

### 計画（ステップ2以降）
*   **`run_tests() -> str`**: `pytest`を実行し、その結果を分かりやすく整理して返す。
*   **`search_code(query: str) -> str`**: プロジェクト内のコードから、関連する部分を検索して返す(RAG)。
*   **`execute_command(command: str) -> str`**: 安全なコマンド実行。

## 7. 開発ロードマップ

*   **[現在地] ステップ1: 最小限実装（完了度: ~95%）**
    *   **目標:** AIとの対話で、単一のファイルを編集できるようにする。✅**達成**
    *   **アーキテクチャ:** シンプルな`while`ループ、`rich`ライブラリによる基本的なUI、ファイルの読み書きツールのみ。✅**実装済み**
    *   **残存課題:** テストスイート、ドキュメント、エラーハンドリング強化

*   **[次の目標] ステップ2: MVP（実用最小限の製品）**
    *   **目標:** 複数ファイルにまたがる、プロジェクトレベルの開発を支援できるようにする。
    *   **アーキテクチャ:** `LangGraph`と`Textual`へ移行。コード検索(RAG)やコマンド実行ツールを追加。

*   **[将来の目標] ステップ3: 実用的なエージェントツール**
    *   **目標:** 日常業務で信頼して使える、洗練された開発パートナーになる。
    *   **アーキテクチャ:** LSPやTree-sitterなどの高度なコード解析ツールを導入。プロンプトを洗練させ、評価の仕組みを本格化させる。

## 8. タスクの進め方 (Steps)
1.  **要件分析**: ユーザーの要求を分析し、不明点を質問して仕様を確定させます。
2.  **設計提案**:
    - 影響範囲（変更・追加するファイル）をリストアップします。
3.  **コーディング**: 上記の全ルールに従い、コードを実装します。
4.  **成果物提示**: 以下の形式で回答を生成します。
5.  **進捗の記録**: 終わったタスクをPROGRESS.mdファイルに記録してどこまで作業を行ったか常に把握できるように

## 9. 成果物 (Deliverables)
- **コード**:
    - 新規作成または変更した**ファイル全体のコード**を提示してください（断片的なコードは不可）。
    - コードブロックの先頭に、`// src/renderer/components/NewComponent.tsx`のように**必ずファイルパスをコメントで記載**してください。
- **解説**:
    - なぜそのように実装したのか、どのような変更を加えたのかを箇条書きで簡潔に説明してください。
- **次のステップ**:
    - `npm install`など、ユーザーが次に実行すべきコマンドがあれば明記してください。

---

### この`Claude.md`の使い方

このドキュメントは、Duckflowプロジェクトの「憲法」です。
**新しい開発タスクを依頼する際は、必ずこの指示書の全文をチャットの最初に貼り付け、その後に「この指示書に従って、〇〇機能を追加してください」のように具体的な要求を続けてください。**

これにより、Claudeは常にプロジェクトの全体像とルールを把握した上で、最適な回答を生成します。